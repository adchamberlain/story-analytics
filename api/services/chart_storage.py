"""
Chart storage: save and load chart configurations as JSON files.
Local-first, Git-friendly persistence.
"""

import json
import logging
import re
import uuid
from datetime import datetime, timezone
from dataclasses import dataclass, asdict, fields as dc_fields

from api.services.storage import get_storage

logger = logging.getLogger(__name__)

_storage = get_storage()

# IDs are 12-char hex strings generated by uuid4().hex[:12]
_SAFE_ID_RE = re.compile(r"^[a-f0-9]{1,32}$")


@dataclass
class SavedChart:
    """A persisted chart configuration."""
    id: str
    source_id: str
    chart_type: str
    title: str
    subtitle: str | None
    source: str | None
    sql: str
    x: str | None
    y: str | list[str] | None
    series: str | None
    horizontal: bool
    sort: bool
    created_at: str
    updated_at: str
    reasoning: str | None = None
    config: dict | None = None  # Visual config blob (palette, toggles, axis labels)
    connection_id: str | None = None  # Database connection this data came from
    source_table: str | None = None   # Original table name (e.g., "INVOICES")
    status: str = "draft"  # "draft" | "published"
    folder_id: str | None = None
    archived_at: str | None = None


def save_chart(
    source_id: str,
    chart_type: str,
    title: str,
    sql: str,
    x: str | None = None,
    y: str | list[str] | None = None,
    series: str | None = None,
    horizontal: bool = False,
    sort: bool = True,
    subtitle: str | None = None,
    source: str | None = None,
    reasoning: str | None = None,
    config: dict | None = None,
    connection_id: str | None = None,
    source_table: str | None = None,
) -> SavedChart:
    """Save a chart configuration to disk."""
    chart_id = uuid.uuid4().hex[:12]
    now = datetime.now(timezone.utc).isoformat()

    chart = SavedChart(
        id=chart_id,
        source_id=source_id,
        chart_type=chart_type,
        title=title,
        subtitle=subtitle,
        source=source,
        sql=sql,
        x=x,
        y=y,
        series=series,
        horizontal=horizontal,
        sort=sort,
        reasoning=reasoning,
        created_at=now,
        updated_at=now,
        config=config,
        connection_id=connection_id,
        source_table=source_table,
    )

    _storage.write_text(f"charts/{chart_id}.json", json.dumps(asdict(chart), indent=2))
    return chart


def _safe_load_chart(data: dict) -> SavedChart:
    """Load a SavedChart from dict, ignoring unknown keys from newer versions."""
    known = {f.name for f in dc_fields(SavedChart)}
    return SavedChart(**{k: v for k, v in data.items() if k in known})


def _validate_id(chart_id: str) -> bool:
    """Return True if chart_id is a safe hex string (no path traversal)."""
    return bool(_SAFE_ID_RE.match(chart_id))


def load_chart(chart_id: str) -> SavedChart | None:
    """Load a chart configuration from disk."""
    if not _validate_id(chart_id):
        return None
    key = f"charts/{chart_id}.json"
    if not _storage.exists(key):
        return None

    try:
        data = json.loads(_storage.read_text(key))
        return _safe_load_chart(data)
    except Exception:
        logger.warning("Failed to load chart %s (schema mismatch?)", chart_id)
        return None


def list_charts(status: str = "active") -> list[SavedChart]:
    """List saved charts, filtered by archive status.

    Args:
        status: 'active' (default, excludes archived), 'archived' (only archived), 'all' (everything).
    """
    charts = []
    for key in _storage.list("charts/"):
        if not key.endswith(".json"):
            continue
        try:
            data = json.loads(_storage.read_text(key))
            chart = _safe_load_chart(data)
        except Exception:
            logger.warning("Skipping corrupted chart file: %s", key)
            continue

        if status == "active" and chart.archived_at is not None:
            continue
        if status == "archived" and chart.archived_at is None:
            continue
        # status == "all" — no filtering
        charts.append(chart)

    # Sort by most recently updated (was mtime, now uses updated_at from chart data)
    charts.sort(key=lambda c: c.updated_at, reverse=True)
    return charts


def update_chart(chart_id: str, **fields) -> SavedChart | None:
    """Update a chart configuration on disk. Merges provided fields."""
    if not _validate_id(chart_id):
        return None
    key = f"charts/{chart_id}.json"
    if not _storage.exists(key):
        return None

    try:
        data = json.loads(_storage.read_text(key))
    except (json.JSONDecodeError, OSError):
        logger.warning("Failed to read chart %s for update (corrupted?)", chart_id)
        return None
    now = datetime.now(timezone.utc).isoformat()

    # Only allow updating presentation fields — protect id, source_id, sql, timestamps
    _UPDATABLE = {"chart_type", "title", "subtitle", "source", "x", "y", "series",
                  "horizontal", "sort", "reasoning", "config", "connection_id", "source_table",
                  "status", "folder_id", "archived_at"}
    for key_name, value in fields.items():
        if key_name in _UPDATABLE:
            data[key_name] = value

    data["updated_at"] = now
    _storage.write_text(key, json.dumps(data, indent=2))
    try:
        return _safe_load_chart(data)
    except Exception:
        logger.warning("Failed to reload chart %s after update (schema mismatch?)", chart_id)
        return None


def delete_chart(chart_id: str) -> bool:
    """Delete a chart configuration."""
    if not _validate_id(chart_id):
        return False
    key = f"charts/{chart_id}.json"
    if _storage.exists(key):
        _storage.delete(key)
        return True
    return False
