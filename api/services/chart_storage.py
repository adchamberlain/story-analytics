"""
Chart storage: save and load chart configurations as JSON files.
Local-first, Git-friendly persistence.
"""

import json
import logging
import os
import re
import tempfile
import uuid
from datetime import datetime, timezone
from pathlib import Path
from dataclasses import dataclass, asdict, fields as dc_fields

logger = logging.getLogger(__name__)

CHARTS_DIR = Path(__file__).parent.parent.parent / "data" / "charts"

# IDs are 12-char hex strings generated by uuid4().hex[:12]
_SAFE_ID_RE = re.compile(r"^[a-f0-9]{1,32}$")


@dataclass
class SavedChart:
    """A persisted chart configuration."""
    id: str
    source_id: str
    chart_type: str
    title: str
    subtitle: str | None
    source: str | None
    sql: str
    x: str | None
    y: str | list[str] | None
    series: str | None
    horizontal: bool
    sort: bool
    reasoning: str | None
    created_at: str
    updated_at: str
    config: dict | None = None  # Visual config blob (palette, toggles, axis labels)
    connection_id: str | None = None  # Database connection this data came from
    source_table: str | None = None   # Original table name (e.g., "INVOICES")


def save_chart(
    source_id: str,
    chart_type: str,
    title: str,
    sql: str,
    x: str | None = None,
    y: str | list[str] | None = None,
    series: str | None = None,
    horizontal: bool = False,
    sort: bool = True,
    subtitle: str | None = None,
    source: str | None = None,
    reasoning: str | None = None,
    config: dict | None = None,
    connection_id: str | None = None,
    source_table: str | None = None,
) -> SavedChart:
    """Save a chart configuration to disk."""
    CHARTS_DIR.mkdir(parents=True, exist_ok=True)

    chart_id = uuid.uuid4().hex[:12]
    now = datetime.now(timezone.utc).isoformat()

    chart = SavedChart(
        id=chart_id,
        source_id=source_id,
        chart_type=chart_type,
        title=title,
        subtitle=subtitle,
        source=source,
        sql=sql,
        x=x,
        y=y,
        series=series,
        horizontal=horizontal,
        sort=sort,
        reasoning=reasoning,
        created_at=now,
        updated_at=now,
        config=config,
        connection_id=connection_id,
        source_table=source_table,
    )

    path = CHARTS_DIR / f"{chart_id}.json"
    _atomic_write(path, json.dumps(asdict(chart), indent=2))
    return chart


def _atomic_write(path: Path, content: str) -> None:
    """Write content to a file atomically via uniquely-named temp file + rename."""
    fd, tmp_name = tempfile.mkstemp(dir=path.parent, suffix=".tmp")
    fd_closed = False
    try:
        os.write(fd, content.encode())
        os.close(fd)
        fd_closed = True
        os.replace(tmp_name, str(path))
    except BaseException:
        if not fd_closed:
            try:
                os.close(fd)
            except OSError:
                pass
        try:
            os.unlink(tmp_name)
        except OSError:
            pass
        raise


def _safe_load_chart(data: dict) -> SavedChart:
    """Load a SavedChart from dict, ignoring unknown keys from newer versions."""
    known = {f.name for f in dc_fields(SavedChart)}
    return SavedChart(**{k: v for k, v in data.items() if k in known})


def _validate_id(chart_id: str) -> bool:
    """Return True if chart_id is a safe hex string (no path traversal)."""
    return bool(_SAFE_ID_RE.match(chart_id))


def load_chart(chart_id: str) -> SavedChart | None:
    """Load a chart configuration from disk."""
    if not _validate_id(chart_id):
        return None
    path = CHARTS_DIR / f"{chart_id}.json"
    if not path.exists():
        return None

    try:
        data = json.loads(path.read_text())
        return _safe_load_chart(data)
    except Exception:
        logger.warning("Failed to load chart %s (schema mismatch?)", chart_id)
        return None


def list_charts() -> list[SavedChart]:
    """List all saved charts."""
    if not CHARTS_DIR.exists():
        return []

    charts = []
    for path in sorted(CHARTS_DIR.glob("*.json"), key=lambda p: p.stat().st_mtime, reverse=True):
        try:
            data = json.loads(path.read_text())
            charts.append(_safe_load_chart(data))
        except Exception:
            logger.warning("Skipping corrupted chart file: %s", path.name)
            continue

    return charts


def update_chart(chart_id: str, **fields) -> SavedChart | None:
    """Update a chart configuration on disk. Merges provided fields."""
    if not _validate_id(chart_id):
        return None
    path = CHARTS_DIR / f"{chart_id}.json"
    if not path.exists():
        return None

    data = json.loads(path.read_text())
    now = datetime.now(timezone.utc).isoformat()

    # Only allow updating presentation fields â€” protect id, source_id, sql, timestamps
    _UPDATABLE = {"chart_type", "title", "subtitle", "source", "x", "y", "series",
                  "horizontal", "sort", "reasoning", "config", "connection_id", "source_table"}
    for key, value in fields.items():
        if key in _UPDATABLE:
            data[key] = value

    data["updated_at"] = now
    _atomic_write(path, json.dumps(data, indent=2))
    try:
        return _safe_load_chart(data)
    except Exception:
        logger.warning("Failed to reload chart %s after update (schema mismatch?)", chart_id)
        return None


def delete_chart(chart_id: str) -> bool:
    """Delete a chart configuration."""
    if not _validate_id(chart_id):
        return False
    path = CHARTS_DIR / f"{chart_id}.json"
    if path.exists():
        path.unlink()
        return True
    return False
