# Phase 7 Implementation Plan: Embed Flags, Chart Types, Accessibility

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Close the remaining high-impact Datawrapper parity gaps — embed render flags, 6 new chart types, and WCAG AA accessibility essentials.

**Architecture:** 3 independent sessions (K, L, M) run in parallel worktrees. Each session touches different files with no overlap, enabling conflict-free merges in any order.

**Tech Stack:** React 18, Observable Plot (D3), Tailwind v4, TypeScript, Vitest

---

## Session K: Embed Render Flags

**Files:**
- Modify: `app/src/pages/EmbedChartPage.tsx` (250 lines)
- Modify: `app/src/pages/EmbedDashboardPage.tsx` (153 lines)
- Create: `app/src/tests/embed-flags.test.tsx`

### Task K.1: Parse Embed Flags

**Step 1: Write the failing test**

Create `app/src/tests/embed-flags.test.tsx`:

```tsx
import { describe, it, expect } from 'vitest'

// Helper to parse embed flags from URLSearchParams (will extract to shared util)
function parseEmbedFlags(params: URLSearchParams) {
  return {
    plain: params.get('plain') === 'true',
    static: params.get('static') === 'true',
    transparent: params.get('transparent') === 'true',
    logo: params.has('logo') ? params.get('logo') === 'on' : null, // null = use theme default
    search: params.get('search') || '',
  }
}

describe('parseEmbedFlags', () => {
  it('returns defaults when no params', () => {
    const flags = parseEmbedFlags(new URLSearchParams(''))
    expect(flags).toEqual({
      plain: false,
      static: false,
      transparent: false,
      logo: null,
      search: '',
    })
  })

  it('parses all flags', () => {
    const flags = parseEmbedFlags(new URLSearchParams('plain=true&static=true&transparent=true&logo=off&search=Europe'))
    expect(flags).toEqual({
      plain: true,
      static: true,
      transparent: true,
      logo: false,
      search: 'Europe',
    })
  })

  it('handles logo=on', () => {
    const flags = parseEmbedFlags(new URLSearchParams('logo=on'))
    expect(flags.logo).toBe(true)
  })

  it('ignores invalid plain value', () => {
    const flags = parseEmbedFlags(new URLSearchParams('plain=yes'))
    expect(flags.plain).toBe(false)
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd app && npx vitest run src/tests/embed-flags.test.tsx`
Expected: PASS (pure function test, no dependencies)

**Step 3: Extract parseEmbedFlags to shared util**

Create `app/src/utils/embedFlags.ts`:

```typescript
export interface EmbedFlags {
  plain: boolean
  static: boolean
  transparent: boolean
  logo: boolean | null // null = use theme default
  search: string
}

export function parseEmbedFlags(params: URLSearchParams): EmbedFlags {
  return {
    plain: params.get('plain') === 'true',
    static: params.get('static') === 'true',
    transparent: params.get('transparent') === 'true',
    logo: params.has('logo') ? params.get('logo') === 'on' : null,
    search: params.get('search') || '',
  }
}
```

Update test to import from `../utils/embedFlags`.

**Step 4: Run tests**

Run: `cd app && npx vitest run src/tests/embed-flags.test.tsx`
Expected: PASS (4 tests)

**Step 5: Commit**

```bash
git add app/src/utils/embedFlags.ts app/src/tests/embed-flags.test.tsx
git commit -m "feat: add parseEmbedFlags utility with tests"
```

---

### Task K.2: Wire Flags into EmbedChartPage

**Files:**
- Modify: `app/src/pages/EmbedChartPage.tsx`
- Modify: `app/src/tests/embed-flags.test.tsx`

**Step 1: Write failing tests**

Add to `embed-flags.test.tsx`:

```tsx
import { render, screen } from '@testing-library/react'
import { MemoryRouter, Route, Routes } from 'react-router-dom'

// Mock chart fetch
vi.mock('../stores/editorStore', () => ({ useEditorStore: () => ({}) }))

describe('EmbedChartPage flags', () => {
  it('hides title/source when plain=true', async () => {
    // Render EmbedChartPage with ?plain=true
    // Assert title and source elements are not in DOM
  })

  it('applies transparent background when transparent=true', async () => {
    // Render EmbedChartPage with ?transparent=true
    // Assert container has background: transparent
  })
})
```

Note: These are integration-level tests. If mocking is complex, convert to simpler unit tests that verify the flag logic independently.

**Step 2: Implement flags in EmbedChartPage.tsx**

At the top of the component (after line 40, the `useSearchParams` call), add:

```typescript
import { parseEmbedFlags } from '../utils/embedFlags'

// After existing useSearchParams:
const flags = parseEmbedFlags(searchParams)
```

Modify the JSX return (starting around line 204):

```typescript
return (
  <div
    ref={containerRef}
    style={{
      padding: flags.plain ? '0' : '12px 16px',
      fontFamily: 'system-ui',
      backgroundColor: flags.transparent
        ? 'transparent'
        : isDark ? '#0f172a' : undefined,
      color: isDark ? '#e2e8f0' : undefined,
    }}
    data-theme={isDark ? 'dark' : 'light'}
  >
    {!flags.plain && chart.title && (
      <h2 style={{ margin: '0 0 4px', fontSize: 16, fontWeight: 600, color: isDark ? '#f1f5f9' : '#1a1a1a' }}>
        {chart.title}
      </h2>
    )}
    {!flags.plain && chart.subtitle && (
      <p style={{ margin: '0 0 8px', fontSize: 13, color: isDark ? '#94a3b8' : '#666' }}>
        {chart.subtitle}
      </p>
    )}
    <ObservableChartFactory
      data={data}
      config={{
        ...chartConfig,
        interactive: flags.static ? false : true,
        initialSearch: flags.search || undefined,
      }}
      chartType={chart.chart_type as ChartType}
      height={360}
    />
    {!flags.plain && chart.source && (
      <p style={{ margin: '8px 0 0', fontSize: 11, color: isDark ? '#64748b' : '#999' }}>
        Source: {chart.source}
      </p>
    )}
    {/* noscript + staleness unchanged */}
  </div>
)
```

For the `logo` flag: modify theme config passed to ChartWrapper:

```typescript
// If logo flag is set, override theme logo visibility
const effectiveTheme = flags.logo !== null
  ? { ...chartTheme, logoUrl: flags.logo ? chartTheme?.logoUrl : undefined }
  : chartTheme
```

**Step 3: Run tests**

Run: `cd app && npx vitest run src/tests/embed-flags.test.tsx`
Expected: PASS

**Step 4: Commit**

```bash
git add app/src/pages/EmbedChartPage.tsx app/src/tests/embed-flags.test.tsx
git commit -m "feat: wire embed render flags into EmbedChartPage"
```

---

### Task K.3: Wire Flags into EmbedDashboardPage

**Files:**
- Modify: `app/src/pages/EmbedDashboardPage.tsx`

**Step 1: Add parseEmbedFlags import and usage**

Same pattern as EmbedChartPage. After `useSearchParams` (line 47):

```typescript
import { parseEmbedFlags } from '../utils/embedFlags'
const flags = parseEmbedFlags(searchParams)
```

Apply `plain`, `transparent`, and `logo` flags to the dashboard page JSX (lines 129-152). The `static` and `search` flags apply to individual chart components within the dashboard grid.

**Step 2: Add tests for dashboard embed flags**

Add dashboard-specific tests to `embed-flags.test.tsx`.

**Step 3: Run tests**

Run: `cd app && npx vitest run src/tests/embed-flags.test.tsx`
Expected: PASS

**Step 4: Commit**

```bash
git add app/src/pages/EmbedDashboardPage.tsx app/src/tests/embed-flags.test.tsx
git commit -m "feat: wire embed render flags into EmbedDashboardPage"
```

---

### Task K.4: Pass initialSearch to RichDataTable

**Files:**
- Modify: `app/src/components/charts/table/RichDataTable.tsx`

**Step 1: Add initialSearch prop**

In RichDataTable, accept an `initialSearch` prop and use it as the default value for the search state (currently line 101):

```typescript
// Change from:
const [search, setSearch] = useState('')
// To:
const [search, setSearch] = useState(config?.initialSearch || '')
```

Alternatively, accept it via the config object if that's cleaner.

**Step 2: Write test**

```tsx
it('pre-fills search from initialSearch prop', () => {
  // Render RichDataTable with config.initialSearch = 'Europe'
  // Assert search input has value 'Europe'
  // Assert rows are filtered
})
```

**Step 3: Run tests**

Run: `cd app && npx vitest run src/tests/embed-flags.test.tsx`
Expected: PASS

**Step 4: Commit**

```bash
git add app/src/components/charts/table/RichDataTable.tsx app/src/tests/embed-flags.test.tsx
git commit -m "feat: support initialSearch prop in RichDataTable for embed ?search= param"
```

---

## Session L: Chart Types (6 New)

**Files:**
- Modify: `app/src/types/chart.ts` (lines 9-28: ChartType union)
- Modify: `app/src/stores/editorStore.ts` (lines 12-68: EditorConfig, line 70: DEFAULT_CONFIG, lines 265-313: loadChart, lines 491-530: saveNew, lines 758-797: save)
- Modify: `app/src/components/editor/ChartTypeSelector.tsx` (lines 4-231: CHART_TYPES array)
- Modify: `app/src/components/charts/ObservableChartFactory.tsx` (lines 226-250: early returns, lines 309-347: buildMarks switch)
- Create: `app/src/components/charts/ElectionDonut.tsx`
- Create: `app/src/components/charts/MultiplePies.tsx`
- Create: `app/src/tests/chart-types-phase7.test.tsx`

### Task L.1: Register 6 New Chart Types

**Step 1: Write the failing test**

Create `app/src/tests/chart-types-phase7.test.tsx`:

```tsx
import { describe, it, expect } from 'vitest'
import type { ChartType } from '../types/chart'

const PHASE_7_TYPES: ChartType[] = [
  'StackedColumn',
  'GroupedColumn',
  'SplitBars',
  'ArrowPlot',
  'ElectionDonut',
  'MultiplePies',
]

describe('Phase 7 chart types', () => {
  it('all new types are valid ChartType values', () => {
    // This test validates at compile time — if it compiles, the types exist
    PHASE_7_TYPES.forEach((t) => {
      expect(typeof t).toBe('string')
    })
  })
})
```

**Step 2: Run test — expect compile error**

Run: `cd app && npx vitest run src/tests/chart-types-phase7.test.tsx`
Expected: TypeScript error — 'StackedColumn' is not assignable to type 'ChartType'

**Step 3: Add types to ChartType union**

In `app/src/types/chart.ts`, add after `'SpikeMap'` (line 28):

```typescript
  | 'StackedColumn'
  | 'GroupedColumn'
  | 'SplitBars'
  | 'ArrowPlot'
  | 'ElectionDonut'
  | 'MultiplePies'
```

**Step 4: Run test**

Run: `cd app && npx vitest run src/tests/chart-types-phase7.test.tsx`
Expected: PASS

**Step 5: Commit**

```bash
git add app/src/types/chart.ts app/src/tests/chart-types-phase7.test.tsx
git commit -m "feat: register 6 new chart types in ChartType union"
```

---

### Task L.2: Add EditorConfig Fields for New Types

**Files:**
- Modify: `app/src/stores/editorStore.ts`

**Step 1: Write failing test**

Add to `chart-types-phase7.test.tsx`:

```tsx
import { DEFAULT_CONFIG } from '../stores/editorStore'

describe('EditorConfig new fields', () => {
  it('has leftColumn default', () => {
    expect(DEFAULT_CONFIG.leftColumn).toBeNull()
  })
  it('has rightColumn default', () => {
    expect(DEFAULT_CONFIG.rightColumn).toBeNull()
  })
  it('has startColumn default', () => {
    expect(DEFAULT_CONFIG.startColumn).toBeNull()
  })
  it('has endColumn default', () => {
    expect(DEFAULT_CONFIG.endColumn).toBeNull()
  })
  it('has pieVariant default', () => {
    expect(DEFAULT_CONFIG.pieVariant).toBe('pie')
  })
})
```

**Step 2: Run test — expect fail**

Run: `cd app && npx vitest run src/tests/chart-types-phase7.test.tsx`
Expected: FAIL — property doesn't exist

**Step 3: Add fields to EditorConfig**

In `app/src/stores/editorStore.ts`, add to the `EditorConfig` interface (after line ~63):

```typescript
  // Split bars
  leftColumn: string | null
  rightColumn: string | null
  // Arrow plot
  startColumn: string | null
  endColumn: string | null
  // Multiple pies
  pieVariant: 'pie' | 'donut'
```

Add defaults to `DEFAULT_CONFIG` (after line ~118):

```typescript
  leftColumn: null,
  rightColumn: null,
  startColumn: null,
  endColumn: null,
  pieVariant: 'pie',
```

Add to `loadChart` (lines 265-313), `saveNew` (lines 491-530), and `save` (lines 758-797):

```typescript
  leftColumn: chart.config?.leftColumn ?? null,
  rightColumn: chart.config?.rightColumn ?? null,
  startColumn: chart.config?.startColumn ?? null,
  endColumn: chart.config?.endColumn ?? null,
  pieVariant: chart.config?.pieVariant ?? 'pie',
```

**Step 4: Run test**

Run: `cd app && npx vitest run src/tests/chart-types-phase7.test.tsx`
Expected: PASS

**Step 5: Commit**

```bash
git add app/src/stores/editorStore.ts app/src/tests/chart-types-phase7.test.tsx
git commit -m "feat: add EditorConfig fields for split bars, arrow plot, multiple pies"
```

---

### Task L.3: Add Chart Type Selector Entries

**Files:**
- Modify: `app/src/components/editor/ChartTypeSelector.tsx`

**Step 1: Add 6 entries to CHART_TYPES array**

Each entry needs `type`, `label`, and `icon` (SVG). Add after the SpikeMap entry (~line 231):

```tsx
{
  type: 'StackedColumn',
  label: 'Stacked Column',
  icon: (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth={2}>
      <rect x="4" y="4" width="4" height="16" rx="0.5" />
      <line x1="4" y1="12" x2="8" y2="12" />
      <rect x="10" y="6" width="4" height="14" rx="0.5" />
      <line x1="10" y1="14" x2="14" y2="14" />
      <rect x="16" y="8" width="4" height="12" rx="0.5" />
      <line x1="16" y1="14" x2="20" y2="14" />
    </svg>
  ),
},
{
  type: 'GroupedColumn',
  label: 'Grouped Column',
  icon: (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth={2}>
      <rect x="2" y="8" width="3" height="12" rx="0.5" />
      <rect x="5.5" y="4" width="3" height="16" rx="0.5" />
      <rect x="10" y="10" width="3" height="10" rx="0.5" />
      <rect x="13.5" y="6" width="3" height="14" rx="0.5" />
      <rect x="18" y="12" width="3" height="8" rx="0.5" />
    </svg>
  ),
},
{
  type: 'SplitBars',
  label: 'Split Bars',
  icon: (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth={2}>
      <rect x="2" y="3" width="8" height="3" rx="0.5" />
      <rect x="14" y="3" width="6" height="3" rx="0.5" />
      <rect x="4" y="9" width="6" height="3" rx="0.5" />
      <rect x="14" y="9" width="8" height="3" rx="0.5" />
      <rect x="3" y="15" width="7" height="3" rx="0.5" />
      <rect x="14" y="15" width="5" height="3" rx="0.5" />
      <line x1="12" y1="1" x2="12" y2="21" strokeDasharray="2 2" />
    </svg>
  ),
},
{
  type: 'ArrowPlot',
  label: 'Arrow Plot',
  icon: (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth={2}>
      <line x1="4" y1="5" x2="16" y2="5" />
      <polyline points="14,3 16,5 14,7" />
      <line x1="6" y1="12" x2="18" y2="12" />
      <polyline points="16,10 18,12 16,14" />
      <line x1="14" y1="19" x2="8" y2="19" />
      <polyline points="10,17 8,19 10,21" />
    </svg>
  ),
},
{
  type: 'ElectionDonut',
  label: 'Election Donut',
  icon: (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth={2}>
      <path d="M4 16 A8 8 0 0 1 20 16" />
      <path d="M7 16 A5 5 0 0 1 17 16" />
    </svg>
  ),
},
{
  type: 'MultiplePies',
  label: 'Multiple Pies',
  icon: (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth={2}>
      <circle cx="7" cy="7" r="4" />
      <line x1="7" y1="7" x2="7" y2="3" />
      <line x1="7" y1="7" x2="10" y2="9" />
      <circle cx="17" cy="7" r="4" />
      <line x1="17" y1="7" x2="17" y2="3" />
      <line x1="17" y1="7" x2="14" y2="9" />
      <circle cx="12" cy="17" r="4" />
      <line x1="12" y1="17" x2="12" y2="13" />
      <line x1="12" y1="17" x2="15" y2="19" />
    </svg>
  ),
},
```

**Step 2: Write test**

```tsx
describe('ChartTypeSelector', () => {
  it('includes all 25 chart types', () => {
    // Import CHART_TYPES and verify length === 25
    // Verify new types are present
  })
})
```

**Step 3: Run tests**

Run: `cd app && npx vitest run src/tests/chart-types-phase7.test.tsx`
Expected: PASS

**Step 4: Commit**

```bash
git add app/src/components/editor/ChartTypeSelector.tsx app/src/tests/chart-types-phase7.test.tsx
git commit -m "feat: add 6 chart type entries to ChartTypeSelector"
```

---

### Task L.4: Implement Stacked Column & Grouped Column Mark Builders

**Files:**
- Modify: `app/src/components/charts/ObservableChartFactory.tsx`

**Step 1: Write failing test**

```tsx
import * as Plot from '@observablehq/plot'

describe('buildStackedColumnMarks', () => {
  it('returns barY marks with fill=series', () => {
    const data = [
      { category: 'A', value: 10, group: 'X' },
      { category: 'A', value: 20, group: 'Y' },
      { category: 'B', value: 15, group: 'X' },
    ]
    const marks = buildStackedColumnMarks(data, 'category', 'value', 'group', {}, ['#1', '#2'])
    expect(marks).toBeDefined()
    expect(marks.length).toBeGreaterThan(0)
  })
})

describe('buildGroupedColumnMarks', () => {
  it('returns barY marks with fx faceting', () => {
    const data = [
      { category: 'A', value: 10, group: 'X' },
      { category: 'A', value: 20, group: 'Y' },
    ]
    const marks = buildGroupedColumnMarks(data, 'category', 'value', 'group', {}, ['#1', '#2'])
    expect(marks).toBeDefined()
    expect(marks.length).toBeGreaterThan(0)
  })
})
```

**Step 2: Implement mark builders**

In `ObservableChartFactory.tsx`, add after existing mark builder functions:

```typescript
function buildStackedColumnMarks(
  data: Record<string, unknown>[],
  x: string | undefined,
  y: string | undefined,
  series: string | undefined | null,
  config: Record<string, unknown>,
  colors: readonly string[] | string[],
): Plot.Markish[] {
  return [
    Plot.barY(data, {
      x: x!,
      y: y!,
      fill: series ?? undefined,
      sort: config.sort ? { x: '-y' } : undefined,
    }),
    Plot.ruleY([0]),
  ]
}

function buildGroupedColumnMarks(
  data: Record<string, unknown>[],
  x: string | undefined,
  y: string | undefined,
  series: string | undefined | null,
  config: Record<string, unknown>,
  colors: readonly string[] | string[],
): Plot.Markish[] {
  return [
    Plot.barY(data, {
      x: series ?? undefined,
      y: y!,
      fx: x!,
      fill: series ?? undefined,
    }),
    Plot.ruleY([0]),
  ]
}
```

Add cases to `buildMarks` switch (after line ~345):

```typescript
case 'StackedColumn':
  return buildStackedColumnMarks(data, x, y, series, config, colors)
case 'GroupedColumn':
  return buildGroupedColumnMarks(data, x, y, series, config, colors)
```

**Step 3: Run tests**

Run: `cd app && npx vitest run src/tests/chart-types-phase7.test.tsx`
Expected: PASS

**Step 4: Commit**

```bash
git add app/src/components/charts/ObservableChartFactory.tsx app/src/tests/chart-types-phase7.test.tsx
git commit -m "feat: implement StackedColumn and GroupedColumn mark builders"
```

---

### Task L.5: Implement Split Bars Mark Builder

**Step 1: Write failing test**

```tsx
describe('buildSplitBarMarks', () => {
  it('returns two barX marks diverging from center', () => {
    const data = [
      { age: '0-10', male: 50, female: 48 },
      { age: '10-20', male: 60, female: 55 },
    ]
    const config = { leftColumn: 'male', rightColumn: 'female' }
    const marks = buildSplitBarMarks(data, 'age', config, ['#4299e1', '#ed64a6'])
    expect(marks).toBeDefined()
    expect(marks.length).toBeGreaterThanOrEqual(2) // left bars + right bars
  })
})
```

**Step 2: Implement**

```typescript
function buildSplitBarMarks(
  data: Record<string, unknown>[],
  x: string | undefined,
  config: Record<string, unknown>,
  colors: readonly string[] | string[],
): Plot.Markish[] {
  const leftCol = (config as { leftColumn?: string }).leftColumn
  const rightCol = (config as { rightColumn?: string }).rightColumn
  if (!leftCol || !rightCol || !x) return []

  return [
    // Left bars (negative direction)
    Plot.barX(data, {
      y: x,
      x: (d: Record<string, unknown>) => -(d[leftCol] as number),
      fill: colors[0] ?? '#4299e1',
    }),
    // Right bars (positive direction)
    Plot.barX(data, {
      y: x,
      x: rightCol,
      fill: colors[1] ?? '#ed64a6',
    }),
    Plot.ruleX([0]),
  ]
}
```

Add to switch: `case 'SplitBars': return buildSplitBarMarks(data, x, config, colors)`

**Step 3: Run tests + commit**

```bash
git commit -m "feat: implement SplitBars mark builder"
```

---

### Task L.6: Implement Arrow Plot Mark Builder

**Step 1: Write failing test**

```tsx
describe('buildArrowPlotMarks', () => {
  it('returns arrow marks from start to end values', () => {
    const data = [
      { category: 'Sales', start: 100, end: 150 },
      { category: 'Costs', start: 80, end: 60 },
    ]
    const config = { startColumn: 'start', endColumn: 'end' }
    const marks = buildArrowPlotMarks(data, 'category', config, ['#4299e1'])
    expect(marks).toBeDefined()
    expect(marks.length).toBeGreaterThanOrEqual(1)
  })
})
```

**Step 2: Implement**

```typescript
function buildArrowPlotMarks(
  data: Record<string, unknown>[],
  x: string | undefined,
  config: Record<string, unknown>,
  colors: readonly string[] | string[],
): Plot.Markish[] {
  const startCol = (config as { startColumn?: string }).startColumn
  const endCol = (config as { endColumn?: string }).endColumn
  if (!startCol || !endCol || !x) return []

  return [
    // Dots at start position
    Plot.dot(data, {
      y: x,
      x: startCol,
      fill: '#94a3b8',
      r: 4,
    }),
    // Dots at end position
    Plot.dot(data, {
      y: x,
      x: endCol,
      fill: colors[0] ?? '#4299e1',
      r: 4,
    }),
    // Arrow lines from start to end
    Plot.link(data, {
      y1: x,
      y2: x,
      x1: startCol,
      x2: endCol,
      stroke: colors[0] ?? '#4299e1',
      strokeWidth: 2,
      markerEnd: 'arrow',
    }),
    Plot.ruleX([0]),
  ]
}
```

Add to switch: `case 'ArrowPlot': return buildArrowPlotMarks(data, x, config, colors)`

**Step 3: Run tests + commit**

```bash
git commit -m "feat: implement ArrowPlot mark builder"
```

---

### Task L.7: Implement Election Donut Component

**Files:**
- Create: `app/src/components/charts/ElectionDonut.tsx`
- Modify: `app/src/components/charts/ObservableChartFactory.tsx` (add early return)

**Step 1: Write failing test**

```tsx
describe('ElectionDonut', () => {
  it('renders SVG hemicycle with correct seat count', () => {
    const data = [
      { party: 'Blue', seats: 120 },
      { party: 'Red', seats: 100 },
      { party: 'Green', seats: 30 },
    ]
    // Render and verify SVG contains arcs
  })
})
```

**Step 2: Implement ElectionDonut.tsx**

```tsx
import { useMemo, useRef } from 'react'
import * as d3 from 'd3'
import type { ChartConfig } from '../../types/chart'

interface ElectionDonutProps {
  data: Record<string, unknown>[]
  config: ChartConfig
  height?: number
  autoHeight?: boolean
}

export function ElectionDonut({ data, config, height = 300, autoHeight }: ElectionDonutProps) {
  const svgRef = useRef<SVGSVGElement>(null)
  const x = config.x // party/group column
  const y = config.y as string // seat count column

  const seats = useMemo(() => {
    if (!x || !y) return []
    return data.map((d) => ({
      label: String(d[x]),
      count: Number(d[y]) || 0,
    }))
  }, [data, x, y])

  const totalSeats = seats.reduce((sum, s) => sum + s.count, 0)

  // Generate hemicycle layout: seats arranged in semicircular rows
  const seatPositions = useMemo(() => {
    const positions: { x: number; y: number; color: string; label: string }[] = []
    const colors = config.palette
      ? d3.schemeCategory10 // fallback; real impl uses palette from config
      : d3.schemeCategory10
    const cx = 200
    const cy = 180
    const rows = Math.max(3, Math.ceil(Math.sqrt(totalSeats / 3)))
    let seatIdx = 0
    let partyIdx = 0
    let partyRemaining = seats[0]?.count ?? 0

    for (let row = 0; row < rows && seatIdx < totalSeats; row++) {
      const radius = 60 + row * 28
      const seatsInRow = Math.max(3, Math.round((totalSeats / rows) * (1 + row * 0.15)))
      for (let i = 0; i < seatsInRow && seatIdx < totalSeats; i++) {
        const angle = Math.PI - (Math.PI * (i + 0.5)) / seatsInRow
        positions.push({
          x: cx + radius * Math.cos(angle),
          y: cy - radius * Math.sin(angle),
          color: colors[partyIdx % colors.length],
          label: seats[partyIdx]?.label ?? '',
        })
        seatIdx++
        partyRemaining--
        if (partyRemaining <= 0 && partyIdx < seats.length - 1) {
          partyIdx++
          partyRemaining = seats[partyIdx]?.count ?? 0
        }
      }
    }
    return positions
  }, [seats, totalSeats, config.palette])

  const h = autoHeight ? Math.max(200, 180 + 20) : height

  return (
    <svg ref={svgRef} viewBox="0 0 400 200" style={{ width: '100%', height: h }}>
      {seatPositions.map((s, i) => (
        <circle key={i} cx={s.x} cy={s.y} r={5} fill={s.color}>
          <title>{s.label}</title>
        </circle>
      ))}
    </svg>
  )
}
```

**Step 3: Wire into factory**

In `ObservableChartFactory.tsx`, add early return (after SpikeMap block, ~line 250):

```typescript
if (chartType === 'ElectionDonut') {
  return <ElectionDonut data={data} config={config} height={height} autoHeight={autoHeight} />
}
```

**Step 4: Run tests + commit**

```bash
git commit -m "feat: implement ElectionDonut hemicycle chart component"
```

---

### Task L.8: Implement Multiple Pies Component

**Files:**
- Create: `app/src/components/charts/MultiplePies.tsx`
- Modify: `app/src/components/charts/ObservableChartFactory.tsx`

**Step 1: Write failing test**

```tsx
describe('MultiplePies', () => {
  it('renders one pie per facet value', () => {
    const data = [
      { region: 'North', category: 'A', value: 10 },
      { region: 'North', category: 'B', value: 20 },
      { region: 'South', category: 'A', value: 15 },
      { region: 'South', category: 'B', value: 25 },
    ]
    // Render with facetColumn='region' — expect 2 pie SVGs
  })
})
```

**Step 2: Implement MultiplePies.tsx**

This component groups data by `facetColumn`, then renders a grid of `PieChartComponent` instances (reusing the existing pie chart). Import `PieChartComponent` from `ObservableChartFactory.tsx` (it may need to be exported).

```tsx
import { useMemo } from 'react'
import type { ChartConfig } from '../../types/chart'

interface MultiplePiesProps {
  data: Record<string, unknown>[]
  config: ChartConfig
  height?: number
  autoHeight?: boolean
}

export function MultiplePies({ data, config, height = 300 }: MultiplePiesProps) {
  const facetCol = config.facetColumn
  const variant = (config as { pieVariant?: string }).pieVariant ?? 'pie'

  const groups = useMemo(() => {
    if (!facetCol) return [{ label: '', data }]
    const map = new Map<string, Record<string, unknown>[]>()
    for (const row of data) {
      const key = String(row[facetCol])
      if (!map.has(key)) map.set(key, [])
      map.get(key)!.push(row)
    }
    return Array.from(map.entries()).map(([label, rows]) => ({ label, data: rows }))
  }, [data, facetCol])

  const cols = Math.min(groups.length, 4)
  const pieH = Math.max(150, height / Math.ceil(groups.length / cols))

  return (
    <div style={{ display: 'grid', gridTemplateColumns: `repeat(${cols}, 1fr)`, gap: 8 }}>
      {groups.map((g) => (
        <div key={g.label}>
          {g.label && (
            <p style={{ textAlign: 'center', fontSize: 12, fontWeight: 600, margin: '0 0 4px' }}>
              {g.label}
            </p>
          )}
          {/* Reuse PieChartComponent with per-group data */}
          <PieChartComponent
            data={g.data}
            config={{ ...config, donut: variant === 'donut' }}
            height={pieH}
            autoHeight={false}
          />
        </div>
      ))}
    </div>
  )
}
```

Note: May need to export `PieChartComponent` from the factory file, or extract it to its own file.

**Step 3: Wire into factory**

```typescript
if (chartType === 'MultiplePies') {
  return <MultiplePies data={data} config={config} height={height} autoHeight={autoHeight} />
}
```

**Step 4: Run tests + commit**

```bash
git commit -m "feat: implement MultiplePies small-multiples pie/donut component"
```

---

### Task L.9: Add Toolbox Fields for New Types

**Files:**
- Modify: Toolbox component (find exact file — likely `app/src/components/editor/Toolbox.tsx` or similar)

Add conditional field groups for:

- **SplitBars**: `leftColumn` and `rightColumn` dropdowns (show when chartType === 'SplitBars')
- **ArrowPlot**: `startColumn` and `endColumn` dropdowns (show when chartType === 'ArrowPlot')
- **MultiplePies**: `pieVariant` radio ('pie' | 'donut') (show when chartType === 'MultiplePies')

Follow the existing pattern used for Range Plot's `minColumn`/`maxColumn` and Bullet Bar's `targetColumn`.

**Commit:**

```bash
git commit -m "feat: add Toolbox config fields for SplitBars, ArrowPlot, MultiplePies"
```

---

## Session M: Accessibility (WCAG AA Essentials)

**Files:**
- Modify: `app/src/types/chart.ts` (add altText to ChartConfig)
- Modify: `app/src/stores/editorStore.ts` (altText in config)
- Modify: `app/src/components/charts/ObservableChartFactory.tsx` (ARIA on SVG)
- Modify: `app/src/components/charts/ChartWrapper.tsx` (keyboard focus, aria container)
- Modify: `app/src/components/charts/table/RichDataTable.tsx` (keyboard sort)
- Modify: `app/src/components/editor/ColorblindPreview.tsx` (warnings)
- Modify: `app/src/utils/colorblind.ts` (warning helpers)
- Modify: Toolbox component (alt text input, colorblind indicator)
- Create: `app/src/tests/accessibility.test.tsx`

### Task M.1: Alt Text Field in Config

**Step 1: Write failing test**

Create `app/src/tests/accessibility.test.tsx`:

```tsx
import { describe, it, expect } from 'vitest'
import type { ChartConfig } from '../types/chart'

describe('Alt text in ChartConfig', () => {
  it('accepts altText field', () => {
    const config: Partial<ChartConfig> = {
      altText: 'Bar chart showing sales by region for Q1 2026',
    }
    expect(config.altText).toBe('Bar chart showing sales by region for Q1 2026')
  })
})
```

**Step 2: Add altText to ChartConfig**

In `app/src/types/chart.ts`, add to `ChartConfig` interface (around line 165, after `source`):

```typescript
  altText?: string
```

**Step 3: Add to EditorConfig and save/load**

In `app/src/stores/editorStore.ts`:

- Add `altText: string` to EditorConfig (after `source`)
- Add `altText: ''` to DEFAULT_CONFIG
- Map in loadChart: `altText: chart.config?.altText ?? ''`
- Include in saveNew and save request bodies: `altText: config.altText`

**Step 4: Add textarea to Toolbox**

In the editor Toolbox, add below the source field:

```tsx
<label className="text-[11px] font-medium text-text-muted uppercase tracking-wide">
  Alt Text (Accessibility)
</label>
<textarea
  value={config.altText}
  onChange={(e) => updateConfig({ altText: e.target.value })}
  placeholder="Describe this chart for screen readers..."
  className="w-full px-2 py-1.5 text-sm border rounded-md resize-y"
  rows={2}
/>
```

**Step 5: Run tests + commit**

```bash
git commit -m "feat: add altText field to ChartConfig with editor UI"
```

---

### Task M.2: ARIA Attributes on SVG Charts

**Step 1: Write failing test**

```tsx
describe('ARIA on chart SVG', () => {
  it('adds role=img to chart container', () => {
    // Render a simple BarChart via ObservableChartFactory
    // Query for [role="img"] — expect to find it
  })

  it('adds aria-label from chart title', () => {
    // Render with config.title = 'Sales by Region'
    // Assert aria-label contains 'Sales by Region'
  })

  it('prefers altText over title for aria-label', () => {
    // Render with title + altText
    // Assert aria-label matches altText
  })

  it('generates chart summary in hidden div', () => {
    // Render BarChart with data
    // Assert hidden summary contains "Bar chart showing..."
  })
})
```

**Step 2: Implement in ChartWrapper.tsx**

Wrap the chart container div (line ~182) with ARIA attributes:

```tsx
// Auto-generate summary text
const chartSummary = useMemo(() => {
  const type = config.chartType?.replace(/([A-Z])/g, ' $1').trim().toLowerCase() ?? 'chart'
  const xCol = config.x ?? ''
  const yCol = typeof config.y === 'string' ? config.y : ''
  const count = data?.length ?? 0
  return `${type} showing ${yCol} by ${xCol} with ${count} data points`
}, [config, data])

const ariaLabel = config.altText || config.title || chartSummary

// In JSX:
<div
  ref={chartAreaRef}
  role="img"
  aria-label={ariaLabel}
  aria-describedby={`chart-summary-${chartId}`}
  className={`flex-1 min-h-0 overflow-hidden flex flex-col ${compact ? 'mt-2' : 'mt-3'}`}
>
  {children}
  <div id={`chart-summary-${chartId}`} className="sr-only">
    {chartSummary}
  </div>
</div>
```

Add to global CSS or Tailwind config: `.sr-only` class for visually hidden but screen-reader-accessible content (Tailwind already has this).

**Step 3: Embed pages: add meta description**

In `EmbedChartPage.tsx`, add after og:image meta tag:

```typescript
{chart.config?.altText && (
  <meta name="description" content={chart.config.altText} />
)}
```

**Step 4: Run tests + commit**

```bash
git commit -m "feat: add ARIA attributes and screen reader summary to charts"
```

---

### Task M.3: Keyboard Focus Indicators

**Step 1: Write failing test**

```tsx
describe('Keyboard focus', () => {
  it('chart wrapper is focusable', () => {
    // Render ChartWrapper
    // Assert tabIndex={0} on container
  })

  it('table header handles Enter key for sort', () => {
    // Render RichDataTable
    // Find first th, fireEvent.keyDown with Enter
    // Assert sort state changed
  })
})
```

**Step 2: Implement in ChartWrapper.tsx**

Add `tabIndex={0}` and focus styles to the main chart wrapper:

```tsx
<div
  tabIndex={0}
  className="... focus:outline-2 focus:outline-blue-500 focus:outline-offset-2"
>
```

**Step 3: Implement keyboard sort in RichDataTable.tsx**

Modify the `<th>` elements (lines 272-289):

```tsx
<th
  key={col}
  onClick={() => handleSort(col)}
  onKeyDown={(e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault()
      handleSort(col)
    }
  }}
  tabIndex={0}
  role="columnheader"
  aria-sort={sortCol === col ? (sortDir === 'asc' ? 'ascending' : 'descending') : 'none'}
  className={`group cursor-pointer select-none px-3 py-2 border-b-2 border-border-default font-semibold text-text-primary whitespace-nowrap focus:outline-2 focus:outline-blue-500 ${
    align === 'right' ? 'text-right' : align === 'center' ? 'text-center' : 'text-left'
  }`}
  style={{ fontSize: 12 }}
>
```

**Step 4: Run tests + commit**

```bash
git commit -m "feat: add keyboard focus indicators and keyboard sort to tables"
```

---

### Task M.4: Colorblind Warnings

**Step 1: Write failing test**

```tsx
import { contrastRatio } from '../utils/colorblind'
import { checkPaletteAccessibility } from '../utils/colorblind'

describe('checkPaletteAccessibility', () => {
  it('returns no warnings for high-contrast palette', () => {
    const result = checkPaletteAccessibility(['#000000', '#ffffff', '#ff0000'])
    expect(result.warnings).toHaveLength(0)
  })

  it('warns when adjacent colors are too similar under protanopia', () => {
    // Red and green look identical under protanopia
    const result = checkPaletteAccessibility(['#ff0000', '#00ff00'])
    expect(result.warnings.length).toBeGreaterThan(0)
    expect(result.warnings[0].cvdType).toBe('protanopia')
  })

  it('identifies problematic color pair indices', () => {
    const result = checkPaletteAccessibility(['#ff0000', '#00ff00'])
    const warning = result.warnings.find((w) => w.cvdType === 'protanopia')
    expect(warning?.pairs).toContainEqual([0, 1])
  })
})
```

**Step 2: Add checkPaletteAccessibility to colorblind.ts**

```typescript
interface PaletteWarning {
  cvdType: string
  pairs: [number, number][]
  message: string
}

interface AccessibilityResult {
  warnings: PaletteWarning[]
  safe: boolean
}

export function checkPaletteAccessibility(
  colors: string[],
  minContrast = 3.0,
): AccessibilityResult {
  const warnings: PaletteWarning[] = []

  for (const { type, label } of CVD_TYPES) {
    const simulated = simulatePalette(colors, type)
    const problematicPairs: [number, number][] = []

    for (let i = 0; i < simulated.length; i++) {
      for (let j = i + 1; j < simulated.length; j++) {
        const ratio = contrastRatio(simulated[i], simulated[j])
        if (ratio < minContrast) {
          problematicPairs.push([i, j])
        }
      }
    }

    if (problematicPairs.length > 0) {
      warnings.push({
        cvdType: type,
        pairs: problematicPairs,
        message: `${problematicPairs.length} color pair(s) may be hard to distinguish for viewers with ${label.toLowerCase()}`,
      })
    }
  }

  return { warnings, safe: warnings.length === 0 }
}
```

**Step 3: Run tests**

Run: `cd app && npx vitest run src/tests/accessibility.test.tsx`
Expected: PASS

**Step 4: Commit**

```bash
git commit -m "feat: add checkPaletteAccessibility utility with contrast warnings"
```

---

### Task M.5: Wire Colorblind Warnings into UI

**Files:**
- Modify: `app/src/components/editor/ColorblindPreview.tsx`

**Step 1: Enhance ColorblindPreview**

```tsx
import { checkPaletteAccessibility } from '../../utils/colorblind'

export function ColorblindPreview({ colors }: ColorblindPreviewProps) {
  const [activeType, setActiveType] = useState<CVDType | null>(null)
  const displayColors = activeType ? simulatePalette(colors, activeType) : colors

  // Check accessibility across all CVD types
  const accessibility = useMemo(() => checkPaletteAccessibility(colors), [colors])

  // Get warning for currently active CVD type
  const activeWarning = activeType
    ? accessibility.warnings.find((w) => w.cvdType === activeType)
    : null

  // Get problematic indices for highlighting
  const problematicIndices = new Set(
    activeWarning?.pairs.flatMap(([i, j]) => [i, j]) ?? []
  )

  return (
    <div className="space-y-2">
      <div className="flex items-center gap-2">
        <p className="text-[11px] font-medium text-text-muted uppercase tracking-wide">
          Colorblind Preview
        </p>
        {accessibility.safe ? (
          <span className="text-[10px] px-1.5 py-0.5 bg-green-50 text-green-700 rounded-full font-medium">
            Safe
          </span>
        ) : (
          <span className="text-[10px] px-1.5 py-0.5 bg-amber-50 text-amber-700 rounded-full font-medium">
            {accessibility.warnings.length} warning{accessibility.warnings.length > 1 ? 's' : ''}
          </span>
        )}
      </div>

      {/* Swatches with warning highlights */}
      <div className="flex gap-0.5">
        {displayColors.slice(0, 8).map((color, i) => (
          <div
            key={i}
            className={`w-6 h-6 rounded-sm transition-colors ${
              problematicIndices.has(i) ? 'ring-2 ring-amber-400 ring-offset-1' : ''
            }`}
            style={{ backgroundColor: color }}
            title={`${colors[i]} → ${color}`}
          />
        ))}
      </div>

      {/* Warning message */}
      {activeWarning && (
        <p className="text-[11px] text-amber-600">
          {activeWarning.message}
        </p>
      )}

      {/* CVD type buttons — same as before */}
      <div className="flex flex-wrap gap-1">
        {/* ... existing button code ... */}
      </div>
    </div>
  )
}
```

**Step 2: Add "Colorblind Safe" indicator to Toolbox palette section**

In the palette selector area of the Toolbox, add a small indicator:

```tsx
{!paletteAccessibility.safe && (
  <p className="text-[11px] text-amber-600 mt-1">
    Palette may not be colorblind-safe
  </p>
)}
```

**Step 3: Write test + commit**

```bash
git commit -m "feat: add active colorblind warnings to ColorblindPreview and Toolbox"
```

---

## Merge & Verify

After all 3 sessions complete:

1. Merge K → main
2. Merge L → main
3. Merge M → main
4. Run full test suite: `cd app && npx vitest run` + `cd api && pytest`
5. Verify test count is ~668 (613 existing + ~55 new)
6. Update `tasks/todo.md` with Phase 7 section
7. Update `memory/MEMORY.md` with new chart count (25) and Phase 7 status
